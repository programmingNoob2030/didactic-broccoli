#### 参考资料

《算法图解》第五章

#### 散列函数

无论传入什么数据,都只返回一个数字(即将输入映射到数字)

特点:

- 一致性:每次输入同样的数据的时候,返回的都是同样的数字
- 互异性:针对不同输入应该有不同的数字(有时候出现**冲突**)

#### 散列表

亦被成为,散列映射,映射,字典和关联数组

与数组链表等直接映射到内存的数据结构不同,散列表使用**散列函数**确定元素的存储位置

组成:

- key(键[**唯一**]) 通过散列函数可以被映射为数字用于在散列表中查找数据
- value(值) 散列表中真正存储的数据可以通过key进行查找

复杂度

- 最坏	

  - 查找:$O(n)$

  - 删除:$O(n)$

  - 查找:$O(n)$

- 平均

  - 查找:$O(1)$

  - 删除:$O(1)$

  - 查找:$O(1)$

对比数组的查找复杂度$O(1)$和链表的增删复杂度$O(1)$,不难发现散列表结合了二者的优点,完美地避免了二者劣势

#### 应用

:one::快速查找​

:two::防止重复(散列表天生自带)

:three::缓存​

#### 冲突

散列冲突就像两个不同的人被错误地分到了同一个储物柜，导致后放东西的人可能会覆盖掉前一个人的物品。实则二人应该一人分得一个柜子

解决方案:

:100::最简单的方案就是将​底层用于存储的数组修改为**链表数组**(可以在同一个位置存储多个数据)。但存放的链表长度过长也会影响效率

所以一个好的散列函数十分重要,理想状态是散列函数将键均匀地映射到散列表的不同位置

除此之外较低的**填装因子**也能有效地避免冲突

:pushpin:值得庆幸的是,现代的编程语言中的散列函数非常稳定和成熟。尽管数学上存在冲突的必然性,冲突发生的概率微乎其微,即使发生也有较为完善的冲突处理机制,开发者无需担心其影响代码编写

#### 填装因子

散列表的填装因子的计算式为: $\large \frac{散列表包含的元素数}{位置总数}$

由于散列表使用数组对元素进行存储

所以分子也可描述为: 数组中被占用位置数, 分母可以描述为: 数组长度

填装因子度量的是散列表中**位置的拥挤程度**,填装因子越大发生冲突的概率越大

:100::当填装因子大于0.7之后,就需要调整散列表的长度了​

