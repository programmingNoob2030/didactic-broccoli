#### 参考资料
网络博客、视频

代码还在调试中，今天主要卡在优先队列的实现细节上，不过对算法的理解更深了。

#### C++运算符重载

我觉得C++的运算符重载比起Java更实用：

```cpp
// C++ 可以直接用在priority_queue中
bool operator>(const Node& other) const {
    return cost > other.cost;
}
```

比Java的`Comparator`接口更简洁直接！

#### 算法思想理解

Dijkstra的**优先队列版本**本质上还是“三表法”思想：

- **距离表**：记录到每个节点的最短距离
- **前驱表**：记录路径
- **访问标记**：优先队列自动处理

但实现起来比数组版本复杂很多!(熟练了其实更加简单,因为无需再手动维护最小节点)

#### 优先队列

`priority_queue<Node, vector<Node>, greater<Node>> pq;`

相比直接操作map，优先队列：

- ❌ 不能随机访问元素
- ❌ 更新节点值比较麻烦
- ✅ 但自动排序，取最小值的效率高(如若用到了结构体还需重载**比较运算符**)

#### 后续目标

搞定那个烦人的优先队列更新逻辑，让代码跑起来！

----

#### 优先队列的作用

**优化了"找最小节点"的过程**：在三表法中，我们需要遍历整个`costs`表来找到当前最小的未访问节点($O(V)$操作)。优先队列自动帮我们维护最小节点,每次`pop()`就是当前最小节点($O(logV)$操作)。

**简化了访问状态管理**：传统三表法需要显式维护节点访问数组来标记已访问节点,而优先队列版本通过"贪心弹出"自然避免了重复处理 即使同一个节点多次入队,只有最小代价的那次会被真正处理。

#### 节点进队的时机

虽然本算法类似于**bfs**,但是不像**bfs**需要将邻接的所有节点都能进队,我们根据访问到某个邻接节点时,到达其位置所需要的最小开销变化与否,来决定它是否入队。这样能够避免重复,提高效率

#### 表结构的精简

**从三表变两表**：

- ❌ 被淘汰：显式的 `visited` 表（访问标记）
- ✅ 保留：`costs` 表（最短距离记录）
- ✅ 可选：`parents` 表（路径追踪）

**优先队列**并没有神奇到让三表法变一表甚至不需要额外的表来记录,而是通过智能的节点管理替代了手工的访问状态维护。

