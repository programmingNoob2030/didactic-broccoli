
你是对的，我错误地修改了原始大纲。让我重新提供完整的原始大纲和对应的简化大纲：

# 原始大纲

## 基础算法

1. 枚举 [1-3]
2. 模拟 [1-3]
3. 排序基础
   - 冒泡排序 [2]
   - 插入排序 [3]
   - 选择排序 [3]
4. 贪心算法 [1-5]
5. 二分查找/二分答案 [2-5]
6. 搜索基础
   - BFS, DFS [1-5]

## 中级算法

1. 动态规划基础
   - 普通一维问题 [3-5]
2. 高精度运算 [1-5]
3. 排序进阶
   - 快速排序 [4-5]
   - 归并排序 [4-5]
   - 堆排序 [4]
   - 桶排序 [4]
   - 基数排序 [4-5]
4. 搜索优化
   - 剪枝 [4-6]
   - 记忆化搜索 [5]
   - 迭代加深搜索 [5-6]
   - 双向BFS [5-6]
5. 数据结构基础
   - 栈 [2-4]
   - 队列 [2-5]
   - 链表 [2-5]
   - 哈希 [4-5]
   - 并查集 [5-6]
   - 堆 [5-6]
   - 树状数组 [5-6]
   - ST表 [5-6]

## 高级算法

1. 动态规划进阶
   - 背包DP [4-6]
   - 树形DP [4-6]
   - 状压DP [5-6]
   - 数位DP [5-6]
   - DP常见优化 [7]
2. 字符串算法
   - KMP [4-6]
   - Manacher [4-6]
3. 图论
   - 拓扑序列 [5-7]
   - DFS序 [5-7]
   - 最小生成树 [5-7]
   - 单源最短路及差分约束系统 [5-7]
   - 最近共同祖先（LCA）[5-7]
   - 欧拉回路 [5-7]
   - 二分图匹配 [7]
   - 图的连通性问题（割点、桥、强连通分量）[7]
4. 数学进阶
   - 初等数论 [3-5]
   - 模意义下的逆元 [5]
   - 排列组合 [5-6]
   - 容斥原理 [6-7]
   - 二项式定理 [6]
   - 矩阵运算 [6-7]
   - 高斯消元 [7]
5. 高级数据结构
   - Trie树 [5-7]
   - 线段树 [6-7]
   - 平衡树 [5-7]
6. 高级算法
   - 启发式搜索 [7]
7. 计算几何与概率
   - 基础计算和基本位置关系判定 [6-7]
   - 概率论 [7+]
   - 博弈论 [7+]

---

# 简化大纲（必须手写/理解部分）

## 基础算法（必须掌握）

1. 贪心算法 [1-5] *（虽然思想简单，但需要设计策略）*
2. 二分查找/二分答案 [2-5] *（必须手写，注意边界条件）*
3. 搜索基础
   - BFS [1-5] *（队列实现，必须手写）*
   - DFS [1-5] *（递归/栈实现，必须手写）*

## 中级算法（必须掌握）

1. 动态规划基础
   - 普通一维问题 [3-5] *（必须理解状态设计和转移）*
2. 高精度运算 [1-5] *（比赛常考，必须手写）*
3. 搜索优化
   - 剪枝 [4-6] *（策略设计需要理解）*
   - 记忆化搜索 [5] *（DFS+DP的混合，必须掌握）*
   - 迭代加深搜索 [5-6] *（需要手写）*
   - 双向BFS [5-6] *（需要手写）*
4. 数据结构基础
   - 并查集 [5-6] *（路径压缩+按秩合并，必须手写）*
   - 树状数组 [5-6] *（lowbit操作，必须手写）*
   - ST表 [5-6] *（RMQ问题，必须手写）*

## 高级算法（必须掌握）

1. 动态规划进阶
   - 背包DP [4-6] *（01、完全、多重背包，必须手写）*
   - 树形DP [4-6] *（树上递归+DP，必须手写）*
   - 状压DP [5-6] *（位运算技巧，必须手写）*
   - 数位DP [5-6] *（DFS+记忆化套路，必须手写）*
   - DP常见优化 [7] *（单调队列、斜率优化等）*
2. 字符串算法
   - KMP [4-6] *（next数组构建，必须手写）*
3. 图论
   - 拓扑序列 [5-7] *（基于BFS/DFS，必须手写）*
   - 最小生成树 [5-7] *（Prim/Kruskal，必须手写）*
   - 单源最短路及差分约束系统 [5-7] *（Dijkstra、SPFA等，必须手写）*
   - 最近共同祖先（LCA）[5-7] *（倍增/Tarjan，必须手写）*
   - 图的连通性问题（割点、桥、强连通分量）[7] *（Tarjan算法，必须手写）*
   - 二分图匹配 [7] *（匈牙利算法，必须手写）*
4. 数学进阶
   - 初等数论 [3-5] *（快速幂、gcd、素数筛，必须手写）*
   - 模意义下的逆元 [5] *（扩展欧几里得，必须手写）*
   - 高斯消元 [7] *（线性方程组求解，必须手写）*
5. 高级数据结构
   - Trie树 [5-7] *（字符串前缀处理，必须手写）*
   - 线段树 [6-7] *（区间操作，必须手写）*
   - 平衡树 [5-7] *（Treap/Splay等，必须手写）*
6. 计算几何与概率
   - 基础计算和基本位置关系判定 [6-7] *（向量运算、凸包等，必须手写）*

---

# STL可替代部分（了解原理，无需手写）

## 可使用STL替代的算法：

1. **所有排序算法**：
   - `std::sort()` 替代快速排序、归并排序
   - `std::stable_sort()` 替代稳定排序
   - `std::partial_sort()` 替代部分排序
   - `std::nth_element()` 替代选择第k小元素
   - `std::make_heap()` 等堆操作替代堆排序

2. **基础数据结构**：
   - `std::stack<>` 替代栈
   - `std::queue<>` 替代队列  
   - `std::deque<>` 替代双端队列
   - `std::priority_queue<>` 替代堆
   - `std::vector<>` 替代动态数组
   - `std::list<>`、`std::forward_list<>` 替代链表
   - `std::map<>`、`std::set<>`、`std::unordered_map<>`、`std::unordered_set<>` 替代哈希表

3. **其他算法**：
   - `std::lower_bound()`、`std::upper_bound()` 替代二分查找
   - `std::next_permutation()` 替代全排列生成
   - 各种STL算法（`accumulate`、`max_element`、`min_element`等）

## 只需了解原理的算法：

1. **基础排序算法原理**（冒泡、插入、选择排序）
2. **排序进阶算法的思想**（桶排序、基数排序的思想）
3. **链表的基本操作原理**
4. **哈希的实现原理**
5. **Manacher算法**（了解思想即可，比赛可用其他方法替代）
6. **欧拉回路算法**（了解Hierholzer算法思想）
7. **DFS序**（了解概念即可）
8. **排列组合、二项式定理、容斥原理**（数学公式，知道即可）
9. **矩阵运算**（了解矩阵乘法等概念）
10. **启发式搜索**（了解A*等思想）
11. **概率论和博弈论**（了解基本概念）

---

# 学习路线建议

## 第一阶段（基础）
1. 二分查找/答案
2. BFS/DFS搜索
3. 简单贪心
4. 一维DP
5. 排序原理（了解）

## 第二阶段（中级）
1. 记忆化搜索
2. 并查集
3. 树状数组
4. 简单图论（拓扑、最小生成树、最短路）
5. 背包DP

## 第三阶段（高级）
1. 线段树
2. 数位DP、状压DP
3. LCA、连通性问题
4. 字符串算法（KMP）
5. 平衡树

## 第四阶段（竞赛级）
1. DP优化（斜率优化等）
2. 网络流、二分图匹配
3. 计算几何
4. 高斯消元
5. 数论进阶