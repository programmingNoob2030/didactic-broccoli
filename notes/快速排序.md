#### 参考资料

《算法图解》第四章、网络、博客

#### 分而治之

分治算法(D&C)是递归的,通常包含如下两个步骤

:one:找出基线条件,这种条件必须尽可能简单

:two:不断将问题分解(缩小规模),直到符合基线条件

:question:什么是分治思想?

分治思想的核心是“分而治之”。面对一个复杂问题时，我们将其分解成若干个规模更小、结构相似的子问题；然后递归地解决这些子问题；最后，将子问题的解合并起来，就得到了原问题的解。这就像举办一场晋级赛，先在各个分赛区决出冠军，最后让所有分区冠军进行总决赛，从而高效地选出总冠军。



:bookmark_tabs:涉及到数组的递归函数的时候,基线条件通常是数组为空或只包含一个元素



#### 快速排序

快速排序是一种“分治”算法。它首先选择一个元素作为基准，然后进行分区，将序列分为小于基准和大于基准的两部分，此时基准自身则位于其最终排序位置。最后，算法递归地对左右两个子序列重复这一过程，直至整个序列有序。

#### 复杂度

快速排序的复杂度与基准值的选择有很大关系

- 最坏：$O(n^2)$
- 平均：$O(nlog_\ n)$

:question:存在一种合并排序时间复杂度稳定为$O(nlog\ n)$,但是运行速度仍然比不过快速排序?

因为我们常用的大$O$表示法通常是省略了常数的一种简便方法,对于一些常数影响很大的算法,例如这里提到的合并排序，虽然时间复杂度上看和快速排序无异,但实际运用时加上常量后差距就出现了

#### 实现方法

快速排序主要有两种实现方法，都采用分治思想但因分区策略不同而各异：

###### :one:Hoare分区法

- **核心思想**：使用双指针从数组两端向中间扫描，左指针找大于基准的元素，右指针找小于基准的元素，交换违规元素，直到指针相遇或交叉
- **特点**：基准元素在分区过程中位置不固定，交换次数较少，性能较好
- **终止条件**：当左右指针相遇或交叉时返回分界点

###### :two:Lomuto分区法

- **核心思想**：使用单指针遍历数组，维护一个"小元素区"边界，将小于基准的元素交换到边界左侧
- **特点**：逻辑线性直观，基准元素在分区完成后被放置到正确位置，代码更易理解但交换次数较多
- **终止条件**：遍历完所有元素后，将基准元素交换到分界点

今日重点理解并实现了Hoare分区版本，掌握了其双指针移动和分区终止的细节。

---

#### 两种实现方法的对比

:heavy_check_mark:**核心区别：基准值的不同角色**

:one:**Hoare法：**

- 基准值身兼两职：既是划分边界的标尺，本身也是需要排序的普通元素
- 在分区过程中，基准值会跟随其他元素一起交换移动
- 不需要对基准值做特殊处理，分区结束时它自然就处于正确的区域
- 递归排序时，分界点要包含在子数组中继续排序

:two:**Lomuto法：**

- 基准值只负责划分边界，不参与排序过程
- 通常选择序列最后一个元素作为基准值，分区时保持不动
- 通过指针记录基准值最终应该放置的位置，分区完毕后再一次性交换到位
- 基准值不进入任何子数组，递归时直接排除

**指针使用的本质分析**

:one:**Lomuto法：**
表面上是单指针遍历，实际上隐含了双指针逻辑：

- 一个指针（`j`）负责扫描数组元素
- 另一个指针（`i`）负责记录小于基准值的边界位置
- 两者配合完成分区，只是实现形式上不那么明显

:two:**Hoare法：**
明确的双指针夹逼策略：

- 左指针从前往后找大于等于基准值的元素
- 右指针从后往前找小于等于基准值的元素  
- 两者找到目标后交换，继续向中间推进直到相遇

**实际编码的体验对比**

:one:**递归范围的处理差异：**

刚开始实现时，我在递归范围的处理上遇到了困惑。Hoare法的递归调用`[left, pi]`和`[pi+1, right]`让我很不理解，直到我意识到这源于其核心特点：**基准值在分区过程中会不断交换移动**，导致分区结束时基准值可能位于`[left, pi]`或`[pi+1, right]`的任何一个位置，因此两个区间都需要继续排序来确保基准值最终到达正确位置。

相比之下，Lomuto法的`[left, pi-1]`和`[pi+1, right]`就直观很多——基准值在分区过程中始终保持不动，只在最后一步交换到正确位置，此时它已处于最终位置，递归时自然应该被排除在外。

这个理解让我认识到两种方法的本质区别：Hoare法的基准值是"参与者"，需要继续参与排序；Lomuto法的基准值是"裁判员"，定位后任务就完成了。

:two:**边界理解的实际感受：**
说实话，Hoare法的边界处理对我来说反而更直观。两个指针从两端向中间走，相遇或者交叉就停止，这个逻辑很自然。倒是Lomuto法中的指针维护让我想了很久——为什么i要从`left-1`开始？为什么遇到小元素时要先`i++`再交换？这些细节需要反复推敲才能理解。

:three:**最初的困惑与突破：**
最让我困惑的是“如何把比基准值小的元素放到左边”——如果选第一个元素作为基准值，索引为0的左边根本没有位置啊！后来通过画图模拟才明白，所谓的“左边”是分区完成后的逻辑位置，基准值在排序过程中是会移动的。这个突破让我真正理解了快速排序的本质：通过交换让元素各归其位，基准值在这个过程中自然找到正确位置。

:four:**实现过程中的坑：**

- Hoare法的死循环问题：一开始没处理好指针移动条件，导致在某些情况下指针卡住不动
- Lomuto法的指针逻辑：那个慢指针i的维护需要仔细理解，不然很容易写错
- 基准值的选择：两种方法都需要注意基准值选取对性能的影响

**学习收获**
通过这两种方法的对比实践，我深刻体会到算法学习的价值不在于记住代码，而在于理解不同解决思路背后的设计哲学。加之网络上面的各种教程虽然多但是参差不齐，一份好的教程可能是雪中送炭，而一份不那么理想的教程的效果可能就没有那么温暖或及时了。